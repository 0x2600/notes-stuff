 易忘: 函数形参， 迭代器与生成器
1. 基本数据类型
Number, String, Tuple 不可变
List, Set, Dictionary 可变

Number:(type()函数查看变量所指的对象类型) int , float, bool, complex
或者 isinstance() 函数, a = 1; isinstance(a, int)
type() 和 isinstance() 区别:
type() 不会认为子类是一种父类类型, isinstance() 会
当指定一个值时，Number 对象就会被创建，可以使用 del 删除对象引用
var = 1; del var
数值运算: + - * / // % **

String

List: reverselist = somelist[::-1]
mylist = input().split(" ") 空格分开传入的参数组成列表, input() 读入字符串,
split() 函数 sep 关键字参数指定分隔字符
reverselist = mylist[::-1]

Tuple: immutable

Set: {}, set() 创建，用于成员关系测试，删除重复元素。{} 创建空字典, 空 set 使用 set() 创建。
成员测试: 'Rose' in castset
集合运算: seta - setb, seta | setb, seta & setb, seta ^ setb, 差集，并集，交集，a, b 不同时存在的元素

Dictionary: 无序的 key-value 集合
key 不可变类型， 且唯一
dict['one'], dict[2], dict.keys(), dict.values()
使用 dict() 构造函数

dict([('one', 1), (2, 'two')])
dict(runoob=1, google=2)
dict([(1, 'one'), ('two', 2)])

数据类型转换
int(x, [,base])
float(x)
complex(x[,y])
str(x)
repr(x)
eval(x)
tuple(x)
list(s)
set(s)
dict(s)
frozenset(s)
chr(x)
ord(x)
hex(x)
oct(x)

2. 运算符
算术运算符
比较运算符: == != < > <= >=
赋值运算符: = += -+ *= /= %= **= //=
位运算符: & | ^ ~ << >>
逻辑运算符: and or not
成员运算符: in, not in
身份运算符: is, is not
x is y, id(x) == id(y), id()用于获取对象内存地址
运算符优先级

3. 数字 Number
支持十六进制，八进制表示整数
num1 = 0xf # 15
num2 = 0o10 # 8
complex: a +bj, complex(a, b)

数字类型转换 int(x[, base]) float() complex(x) complex(x, y)
数字运算(算术运算符) + - * / // % **
>>> 7//2
3
>>> 7.0//2
3.0
交互模式下, 最后被输出的表达式结果被赋值给 _

数学函数 import math
fabs(x) abs() 是内置函数，math.fabs()  
ceil(x) 上入整数
exp(x) e ** x
floor(x) 下舍整数 
log(x) # math.log(math.e) = 1.0, math.log(100, 10) = 2.0
log10(x) # math.log10(100) = 2.0
max(x1, x2, ...) 
min(x1, x2, ...) 
modf(x) Return the fractional and integer parts of x. Both result carry the sign of x and are float.
>>> math.modf(3.2)
(0.200..., 3.0)
pow(x, y) # 内置函数 pow(x, y, z=None, /) return x**y or x**y % z. math 模块pow(x, y, /) return x**Y.
round(x[, n]) # 内置函数，round(number, ndigits=None) 省略 ndigits 返回整数，否则返回值有 number 相同的类型。四舍五入。
sqrt(x) # 平方根
三角函数
acos asin atan...

数字常量 pi e

随机数函数 import random
choice(seq) # Choose a random element from a non-empty sequance.
randrange(start, stop=None, step=1, _int=<class 'int'>) # Choose a random item from range(start, stop[, step]). This fixed the problem with randint() which includes the endpoint.
random() [0, 1)
seed(a=None, version=2) # No need if u don't understand. 
shuffle(x, random=None) # Shuffle list x in place, and return None. 
uniform(a, b) # [a, b) or [a, b]


4. 字符串
转义字符
\ \\ \' \" \a \b \000 \n \t \v \r \n \f \oyy \xyy 
字符串运算符
+ * [] [:] in, not in, r/, R/ 
% # 格式字符串: print("%s %d" % ('aaa', 1))
字符串格式化
%c %s %d %u %o %x %X %f %e %E %g %G %p
格式化操作符辅助指令: 略
三引号:  HTML/SQL
''' """

f-string # py3.6 引入，字面量格式化字符串
>>> name='ruby'
>>>f'hello {name}'
'hello ruby'

py3.8 = 将表达式和结果连接起来
>>> x=1
>>> f'{x+1=}'
'x+1=2'

字符串内建函数
str.join(iterable) # return a string. A TypeError will be raised if there are any non-string values in iterable, including bytes objects.
>>> '.'.join(['1', '2'])
'1.2'
>>> ':'.join(['root', '/bin/bash'])
'root:/bin/bash'

# io.StringIO example usage:
import io
output=io.StringIO()
output.write("First line.\n")
print("Second line.", file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()

str.capitalize() 
>>> 'python dev.'.capitalize()
'Python dev.'
str.center(width[, fillchar])
>>> 'abs'.center(9, '+')
'+++abs+++'
str.count(sub[, start[, end]])

bytes.decode
encode
str.endswith(suffix[, start[, end]])
>>> 'windows'.endswith('ws')
True

str.find(sub[, start[, end]]) # Return the lowest index. Return -1 if sub is not found.
Note: the find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator.
>>> 'Py' in 'Python'
True

str.index(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found.

str.isalnum()  
str.isalpha()
str.isdigit()
str.isnumeric()
str.isspace()
str.isupper()
str.islower()
len
str.just
lower
lstrip
max
min
str.replace(old, new[, count]) # If the optional argument count is given, only the first count occurrences are replaced.

str.rfind(sub, [start[, end]]) # Like find(), but return the highest index.
str.rindex() # Like rfind() but raises ValueError when the substring is not found.
rjust
rstrip
str.split(sep=None, maxsplit=-1) # Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done.
str.splitlines
str.startswith(prefix[, start[, end]])
str.strip([chars]) # default remove whitespace, all combinations of chars values is tripped.

str.swapcase()
str.upper()
isdecimal

5. 列表
序列都可进行的操作: 索引, 切片, 加，乘，检查成员
内置确定序列的长度和最大最小元素
更新列表: append
删除列表元素: del list[2]
列表函数方法
len max min list()
append count extend index insert pop remove reverse sort clear copy

6. 元组
删除元组， 元组元素不能删除，可以使用 del 删除整个元组

元组内置函数 len max min tuple()

7. 字典
删除字典元素
del dict['somekey']
dict.clear() # 	清空内容
del dict # 删除对象引用
字典的 key 必须唯一， 不可变
字典内置函数
len str(dict) type() 
clear() copy() fromkeys() get(), key in dict, iterms() keys() setdefault() update values() pop(key) popitem

8. 集合 Set
无序不重复元素序列
创建: {}, set(), 空集合不能使用 {} 创建， 此将会创建空字典

集合推导式 Set comprehension

集合的基本操作
添加元素 add(), 如果元素存在 不进行任何操作
update(x), x 可以是列表，元组，字典等
移除元素
remove(x), 元素 x 不存在会发生错误
discard(x), x 不存在也不会发生错误
pop() 随机删除集合中的一个元素， 脚本模式随机删除，交互模式删除第一个元素
计算集合元素个数
len(s)
清空集合
s.clear()
成员存在与否
x in s
集合内置方法完整列表
add() clear() copy() difference() difference_update() discard() intersection() intersection_update() isdisjoint() issubset() issuperset() pop() remove() union() update()

9. 条件控制
if, elif, else
没有 switch case

10. 循环语句
for, while
没有 do...while
while 循环使用 else 语句。 条件语句为 false 时执行 else 语句。
# while...else
count = 0
while count < 5:
	print(count, "less than 5")
	count ++
else:
	print(count, "greater than or equal to 5")

for 循环遍历任何序列的项目
range(2): 0 1
range(0, 10, 3)
list(range(3)): [0, 1, 2]
break 跳出 for/while 循环体, else 将不会执行。else 执行条件: 条件为假, 或者列表穷尽(for)
# 找质数
n = int(input())
for i in range(2, n):
	for j in range(2, i):
		if i%j ==0:
			break
	else:
		print(i)

pass 语句

12. 迭代器与生成器
迭代器从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器两个基本方法: iter(), next()
字符串，列表，元组都可用于创建迭代器
''' 创建迭代器 '''
_list = [1, 2, 3]
it = iter(_list)
print(next(it))

''' for 遍历迭代器对象 '''
_list = [1, 2, 3]
it = iter(_list)
for i in it:
	print(i, end=" ")

创建迭代器
把一个类作为一个迭代器使用需要在类中实现两个方法: __iter__(), __next__()
''' __iter__(), __next__()
'''
class MyNumber:
	def __iter__(self):
		self.a = 1
		return self

	def __next__(self):
		if self.a <= 10:
			x = self.a
			self.a += 1
			return x
		else:
			raise StopIteration

if __name == "__main__":
	myclass = MyNumber()
	it = iter(myclass)
	for i in it:
		print(i)
# output: 1-10

生成器， 返回迭代器的函数。调用生成器函数，返回的是一个迭代器对象

13. 函数
参数传递: 分可变类型与不可变类型 mutable immutable
不可变类型: 类似值传递，如 Number, String, Tuple
可变类型: 引用传递
函数形参: 必需参数，关键字参数，默认参数，不定长参数
必须参数: 调用时须以声明时的顺序传入参数
关键字参数: 函数调用时参数的顺序可以和声明时的顺序不一致
def PrintInfo(name, age):
	print(name, age)
# 调用: PrintInfo(age=22, name="Jerry")
output: Jerry 22
默认参数: 位于最后
可变参数: def fun(arg1, *arg_tuple) # 元组形式传入
def fun(arg1, **arg_dict) # 字典形式传入 fun(1, a=1, b=2)

匿名函数 lambda
语法: lambda [arg1[,arg2,...argn]]:expression
mysum = lambda arg1, arg2: arg1 + arg2

return 语句，不带参数值的 return 语句返回 None

14. py3 数据结构
列表

list.append(x) 
list.extend(x)
list.insert(i, x)
list.remove(x)
list.pop([i])
list.clear()
list.index(x)
list.count(x)
list.sort(x)
list.reverse()
list.copy()

列表当作堆栈使用 append(), pop

列表当作队列使用
from collections import deque
queue = deque(['a', 'b', 'c'])
queue.append('c')
queue.append('d')
queue.popleft() # 'a'
queue.popleft() # 'b'

列表推导式
vec = [2, 4, 6]
[3*x for x in vec] # [6, 12, 18]
[[x, x**2] for x in vec] # [[2, 4], [4, 16], [6, 36]]
过滤器
[3*x for x in vec if x>3] # [12, 18]
# 100 以内素数
[x for x in range(2, 101) if not [y for y in range(2, x) if x % y == 0]]

# 嵌套列表
matrix = [[1,2,3],[4,5,6],[7,8,9]]
[[row[i] for row in matrix] for i in range(3)] # [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
元组和序列

集合
集合推导式
a = {x for x in 'abc' if x not in 'ab'} # {'c'}

字典
字典推导式
{x: x**2 for x in (2, 4, 6)} # {2: 4, 4: 16, 6: 36}
dict(sape=1, guido=2, jack=3) # {"sape": 1, "guido": 2, "jack": 3}
遍历技巧
# 字典遍历 key 和 value
for k,v in MyDict.items():
	print(k, v)
# 序列遍历索引位置和值
for i, v in enumerate([3,2,1])
	print(i, v)
# output 0 3\n1 2\n2 1

同时遍历多个序列
q = ['name', 'age']
a = ['jerry', 22]
for q_, a_ in zip(q, a):
	print(q_, a_)
# output: name gary\nage 22\n

15. 模块
模块搜索路径 sys.path, 第一个空串，表示当前目录
每个模块都有一个 __name__ 属性， 为 __main__ 表示模块自身在运行， 否则则为导入
dir() 函数，找到模块内定义的所有名称
标准模块
包
导入语句遵循如下规则: 如果包定义文件 __init__.py 存在 __all__ 的列表变量，那么在使用 from package import * 时将把这个列表中的所有名字导入
推荐方法: from package import specific_submodule

16. 输入和输出
str(), repr()
str.format
print("{}, {}".format("1", "2"))
print("{1}, {0}".format('one', 'two'))
print("{name}, {age}".format(name='gary', gae=22))

读取键盘输入
input

读写文件
open(filename, mode) 返回文件对象
文件对象的方法: f.read(size), 省略时返回文件所有内容
f.readline() 读取单独的一行, \n, 如果返回一个空字符串，说明已经读取最后一行
f.readlines()
f.write()
f.tell() 文件对象当前所处的位置
f.seek(offset, from_what) from_what: 0 开头， 1 当前位置， 2 文件结尾
f.close(), with open("some_file") as f:

pickle 模块实现基本的数据序列和反序列化
序列化操作将程序中运行的对象信息保存到文件中去
反序列化操作从文件中创建上一次程序保存的对象
pickle.dump(obj, file[, protocol])
x = pickle.load(file)

17. py File 方法
18. OS 模块
os.listdir(path)
os.mkdir(path[, mode])
os.remove(path)
os.removedirs(path)
os.rename(src,dst)
19. 错误与异常
try 语句: 没有异常，忽略 except 子句，有异常，try 子句余下的部分被忽略
一个 except 可以同时处理多个异常，这些异常被放在一个括号里成为一个元组
except(RuntimeError, TypeError, ValueError, NameError)
最后一个 except 子句可以忽略异常的名称，当作通配符使用
''' ex '''
try:
	f = open("somefile")
	s = f.read()
	i = str(s.strip())
except OSError:
	print("OS Error.")
except ValueError:
	print("Value Error")
except:
	print("Unexpected Error")
	raise
else 子句，放在所有的 except 子句之后，try 子句没有发生异常时执行
抛出异常
raise NameError("Hi there")
定义清理行为
finally 子句任何情况下都会执行
assert 断言， 语法: assert expression, expression 为假时触发异常 AssertionError

20. 面向对象
类的继承允许多个基类，派生类可以覆盖基类的方法
class ClassName:
	pass
类有一个 __init__() 的特殊方法(构造方法), 在类实例化时自动调用
self 代表类的示例，self 不是 py 的关键字， 可以换成其他

类的方法
def 关键字定义， 第一个参数为 self
继承: class DerivedClassName(BaseClassName):
多个基类时，从左到右搜索基类的方法
''' 继承示例
'''
class People:
	name = ''
	age = 0
	__weight = 0 # 私有属性
	def __init__(self, n, a, w):
		self.name = n
		self.age = a
		self.__weight = w
	def speak(self):
		print(self.name, self.age)

class Student(People):
	grade = ''
	def __init__(self, n, a, w, g):
		People.__init__(self, n, a, w) # 调用父类的构造函数
		self.grade = g
	# 覆盖父类的方法
	def speak(self):
		print(self.name, self.age, self.grade)
'''if __name__ == "__main__":
	s = Student("gary", 22, 60, 'A')
	s.speak()
'''
# 多重继承
class Speaker:
	name = ''
	topic = ''
	def __init__(self, n, t):
		self.name = a
		self.topic = t
	def speak(self):
		print(self.name, self.topic)

class Sample(Student, Speaker):
	def __init__(self, n, a, g, t):
		Student.__init__(self, n, a, g)
		Speaker.__init__(self, n, t)
	def speak(self):
		print(self.name, self.age, self.grade, self.topic)

if __name__ == "__main__":
	MySam = Sample('jerry', 22, 60, 'A', 'Python')
	MySam.speak()

# output: jerry 22 60 A Python\n

方法重写
class Parent:
	def fun(self):
		print("Parent")

class Child(Parent):
	def fun(self):
		print("Child")

c = Child()
c.fun() # output: Child\n, 调用子类重写方法
super(Child, c).fun() # output: Parent\n, 利用子类对象调用父类被覆盖的方法

super() 函数， 调用父类的一个方法
super 解决多重继承问题， 涉及查找顺序(MRO)，重复调用(钻石继承)
super(type[,object-or-type])
''' py3 '''
class A:
	def add(self,x):
		print(x+1)

class B(A):
	def add(self,x):
		super().add(x)
b = B()
b.add(2) # output: 3\n
''' py2 '''
class A(object):
	def add(self,x):
		print(x+1)

class B(A):
	def add(self,x):
		super(B, self).add(x)

b = B()
b.add(2) # output: 3\n

notes 1:
1) 构造方法中的初始值无法继承问题
class Bird():
	def __init__(self):
		self.hungry = True
	def eat(self):
		if self.hungry:
			print("Aha")
		else:
			print("No, thanks")

class SingBird(Bird):
	def __init__(self):
		self.song = "Squawk"
	def sing(self):
		print(self.song)

sb = SingBird()
sb.sing() # Squawk
sb.eat() # 错误， eat() 方法继承了， hungry 没有继承

解决办法:
调用未绑定的超类构造方法
class SingBird(Bird):
	def __init__(self):
		Bird.__init__(self)
		self.song = "Squawk"
	def sing(self):
		print(self.song)

使用 super() 函数
class SingBird(Bird):
	def __init__(self):
		super(SingBird, self).__init__()
		self.song = "Squawk"
	def sing(self):
		print(self.song)

notes 2:
refer to super_.py

类属性与方法
类的私有属性
__private_attrs, 两个下划线开头，不能在类的外部使用, 可在类内部使用
类的方法，def 关键字定义， 必须包含第一个参数 self
类的私有方法， __private_mothod， 外部不能调用私有方法，类内部的公有方法可以调用私有方法，再被外部调用

类的专有方法:
__init__ 构造方法，生成对象时使用
__del__ 析构函数，释放对象时使用
__repr__
__setitem__
__getitem__
__len__
__cmp__
__call__
__add__
__sub__
__mul__
__truediv__
__mod__
__pow__

运算符重载
class Vec:
	a = 0
	b = 0

	def __init__(self, c, d):
		self.a = c
		self.b = d
	def __add__(self, other):
		return Vec(self.a + other.a, self.b + other.b)


vec = Vec(1, 2) + Vec(3, 4)
print(vec.a, vec.b) # 4 6


21. 命名空间和作用域
命名空间 namespace
内置名称 built-in namespace, Python 内置的名称, abs, char, BaseException, Exception
全局名称 global namespace, 模块中定义的名称
局部名称 local namespace, 函数中定义的名称
命名空间查找顺序: local->global->built-in

作用域 scope: local->enclosing->global->built-in
内置作用域通过 builtins 模块
import builtins
dir(builtins)

Python 只有模块 module, class, def, lambda 才会引入新的作用域, if/elif/else, try/except, for/while 不会引入作用域
ex.
if True:
    msg = 'I'
print(msg) # I\n

函数外->全局变量和函数内->局部变量

global 和 nonlocal 关键字
''' 函数内修改全局变量 '''
num = 1
def fun():
    global num # 声明这是一个全局变量
    num = 2

fun()
print(num) # 2

''' 嵌套函数修改外层函数数据 '''
def out():
    num = 1
    def inner():
        nonlocal num
        num = 2
    inner()

out() # num = 2

''' 错误, 未定义的局部变量 '''
a = 10
def fun():
    a = a + 1
    print(a)

test()


22. 标准库概览
os, shutil, glob, sys.argv, sys.stdout.write(), re, math, random, urllib.request, smtplib, datetime, 

#
from datetime import date
now = date.today()
birth = date(1997, 4, 15)
diff = now - birth
diff.days # days
#

数据压缩 zlib
打包和压缩格式: zlib, gzip, bz2, zipfile, tarfile 

性能度量
timeit.Timer
profile, pstats

测试模块
doctest
unittest


23. 实例
# 三角形面积
def area(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5
# I almost forget.

math.factorial(x) # x 不能是负数，非整形

# 判断字符串是否是数字
def is_num(s):
    """
    is_num('四') # True
    is_num('1.1') # True
    is_num('1e3') # True
    """
    try:
        float(s)
        return True
    except ValueError:
        pass

    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
    return False

# 9 * 9 
for i in range(1, 10):
    for j in range(1, i+1):
        print("{} * {} = {}".format(j, i, j * i), end = " ")
    print()

# calendar.month
print(calendar.month(1997, 5))

# 将字符串内容作为代码执行
def exec_code():
    code = '''
def fact():
    fact = 1
    for i in range(1, 6):
        fact *= i
    print(fact)
fact()
'''
    exec(code)

exec_code() # 120 

24. 内置函数
1) abs() 与 fabs(): abs 可以计算复数，返回模大小。fabs要从 math
模块导入，不能计算复数。
2) dict() 用于创建字典。
mydict = dict() # {} 空字典
mydict = dict(a=1, b=2) # {'a': 1, 'b': 2} 传入关键字
mydict =  dict(zip(['one', 'two'], [1, 2])) 映射函数
mydict = dict([('one', 1), ('two', 2)]) 可迭代对象
3) help, help([ogject])
help(math)
help(str)
help(mydict.keys)
help(mydict)
4) min()
5) setattr(object, name, value)
class A(object):
    name = ''
    age = 0
a = A()
setattr(a, name, 'jerry')
getattr(a, name)
6) all(), 判断可迭代参数的元素是否都是 True,除了0,空,None, False外
空列表，空元组返回 True
7) dir([object])
8) hex() 返回给定 Number 的十六进制表示，字符串类型
9) next()
10) zip(), zip(iter1[, iter2 [...]]) 返回每个可迭代对象元素组成的元组， 长度由最小可迭代对象决定。 zip(*) 解压



Python for the Web:
Interacting with Websites and APIs Using Python
requests

Processing JSON in Python
simplejson

Scraping the Web Using Python
lxml

Python Web Sites
Django
