实例方法和类方法。
实例方法可以操作实例变量和类变量。
类方法不仅可以通过类名调用，也可以通过实例对象调用。类方法不可以操作实例变量。

Java 两种多态
方法重载(overload)
方法名字相同，但是：
参数的个数不同，
参数个数相同，但参数列表中对应的某个参数类型不同。

this 关键字可以出现在构造方法和实例方法，不可以出现在类方法中。this 出现在构造方法表示该构造方法创建的对象。出现在实例方法表示正在调用该方法的当前对象。
this 不能出现在类方法中：类方法可以通过类名调用，这时可能还没有任何对象产生。

包
Lader.java
package name.misc;

public class Lader{
    double x, y, z;
    Lader(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    double sum(){
        return x + y + z;
    }

}
然后写一个包含主类的源文件 Example.java
package name.misc;

这里直接使用 Lader 类(同目录的命名包内)。这两个文件都位于 name/misc 目录内。在顶级目录编译 javac name/misc/*.java, 运行 java name.misc.Example 。
导入包： 在顶级目录编写包含主类的 Example2.java 
import name.misc.Lader;
就可以使用别的包内的类。

访问权限
针对对象是否可以操作变量和调用方法。
在类中，实例方法总是可以操作实例变量和类变量。类方法总是可以操作类变量。

私有变量和私有方法 private 修饰
创建这样的对象后，该对象不能操作自己的变量。包括使用实例操作实例变量和类变量，使用类名调用类方法和操作类变量。

共有变量和共有方法 public
在别的类中创建这样的对象，可以自由使用该对象操作变量和调用方法。

友好变量和友好方法，不使用 public, private, protected 修饰
如果在同一个包中的类中创建这样的对象，效果等同于 public
不在同一个包中的类中，比如 import 引入的其他包中类创建的对象，不能访问自己的变量和方法。

受保护的成员变量和方法
与友好相似，在子类上不同

public 类和友好类
public class A{...}，称为 public 类，可以在任何一个类中使用该 public 类创建对象。
无修饰的类 class B{...} 称为友好类，可以使用该类在别的类中创建对象，只有别的类和该类在同一个包中。
类不可以使用 protected 和 private 修饰。

基本数据类型的类封装
Doubel, Float 类
Byte, Short, Integer, Long, Character 类。 

对象数组
Student [] stu;
stu = new Student[10];
stu[0] = new Student();

反编译和文档生成器
javap java.awt.Button // public 属性的方法和变量。
javap -private java.awt.Button // 全部

javadoc -d <dir> Example.java //生成文档

使用 java 运行环境扩展中类
使用 jar 将一些类的字节码文件压缩成一个 jar 文件，放到 jre/lib/ext 目录使用。
1. 有包名的类
先生成字节码。然后在顶级目录编写 Manifest 文件，比如
Manifest-Version: 1.0
Class: name.misc.TestOne name.misc.TestTwo
Created-By: 1.6
生成 jar 文件。 jar cfm hello.jar hello.mf name/misc/*.class
放到 ext 目录。别的源文件 import 使用。
2. 无包名的类
步骤相似。无须 import



// liaoxuefeng

子类覆写的方法可以通过 super 调用。
super.foo()

final 继承允许子类覆写父类的方法，如果父类不允许子类对其某个方法覆写，可以使用 final 修饰。

如果一个类不允许其他类继承自他，可以使用 final 修饰。
final class Person
final 修饰的变量初始化后不可修改。
可以在构造方法中初始化 final 字段
class Person{
    private final String name;
    public Person(String name){
        this.name = name;
    }
}

一个构造方法可以调用别的构造方法。语法是 this(...)
class People{
    String name;
    int age;

    public People(String name, int age){
        this.name = name;
        this.age = age;
    }

    public People(String name){
        this(name, 18);
    }

    public People(){
        this("Unamed");
    }
}

super 关键字
class Person{
    protected String name;
    protected int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
}

class Student extends Person{
    protected double score;

    public Student(String name, int age, double score){
        super(name, age); // 调用父类的构造方法。 如无明确指明，调用 super();
        this.score = score;
    }
}

向上转型
Person p = new Student(); // upcasting
向下转型 downcasting
p instanceof P -> true, false // 判断类型, null 对任何类型的判断都是 false.

继承和组合 is, has 关系

@override //放在希望覆写的方法之前。编译器会帮忙检查。
上转型对象调用被覆写的方法，实际调用覆写的方法。
如：
Person p = new Student();
p.run(); // Student run

在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。
ex: 结果 3.0
public class Main{
	public static void main(String[] args){
		A a = new B();
		System.out.println(a.getNum());
	}	
}

class A{
	public static float getNum(){
		return 3.0f;
	}
}

class B extends A{
	public static float getNum(){
		return 4.0f;
	}
}
多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。

如果一个类的某个方法目的就是让子类覆写它，那么可以用 abstract 修饰，这个方法要写出方法头，实现由子类实现。同时该父类也不能实例化，所以也要 abstract 修饰。 

面向抽象编程：
Person s = new Student();
Person t = new Teacher();
s.run();
t.run();
引用高层类型，避免引用实际子类型的方式。
特点：
上层代码只定义规范
不需要子类就可以实现业务逻辑（正常编译）
具体的业务逻辑由不同的子类实现。

当一个类的所有方法都是抽象方法时，可以把该抽象类改写为接口
接口定义： 接口声明和接口体
接口体包含常量的声明（没有变量）和抽象方法两部分（没有普通方法）常量均为 public static final (修饰符允许省略)，方法均为 public abstract(允许省略)
接口中的常量必须显式初始化。
接口中的静态方法：java版本不同标准不同
interface Person{
    int MAX; // public final static int MAX;
    void run(); // public abstract void run();
}

一个类可以实现多个接口
class Student implements Person, Hello{
    ...
}
一个非抽象类实现了某个接口，要重写这个接口的所有方法。接口方法的修饰符是 public abstract，实现类的方法去掉 abstract，而且要明确指明 public.
在别的类中，可以直接使用接口的常量 Person.NUMBER（static 特性） // int NUMBER

如果一个类声明实现了一个接口，但没有重写所有的方法，那么这个类必须是抽象类。

public 修饰的接口可以被任何类实现，不修饰的接口只能被同一个包中的类实现。

如果父类实现了某个接口，那么其子类自然实现了该接口，不必显示声明实现了该接口 class SonClass implements...

接口也可以被继承，子接口继承所有的常量的抽象方法。 // public

接口回调
接口作为一个引用型数据类型，可以创建接口变量。该变量可以存放实现了该接口的类的实例的引用。该变量可以调用类中实现的接口方法，不可以调用非接口方法。

抽象类可以定义变量，interface 不可以定义变量。
抽象类可以定义抽象方法和非抽象方法。interface 可以定义抽象方法和 default 方法。

interface 的 default 方法在 interface 中实现。这样在 interface 类中增加方法，实现 interface 的类无需改变。

静态字段属于类的字段，为所有的实例所共享。不推荐使用实例访问静态字段。实例能够访问静态字段只是因为编译器可以根据实例类型转换为类名来访问静态对象。

静态方法属于 class，静态方法内部不能访问　this　变量，也无法访问非静态字段。通过实例变量也可以调用静态方法，不过只是编译器自动帮我们把实例改写为类名。
静态方法经常用于工具类.
Array.sort()
Math.random()

interface 虽然不能有实例字段,但是可以有 static final 字段.
public interface Person{
    public static final int MALE = 1; // 可以省略 public static final
    public static final int FEMALE = 1;
}


import 语句三种写法
1. 写完整报名，此时不用 import
2. import 某个类，然后直接使用
* 表示包下所有的类，不包括子包的类。
3. import static java.lang.System.*; // 导入 System 类的所有静态字段和方法。

自动导入： 当前包的其他类。java.lang 包

作用域：
public: class, interface 可以被其他任何类访问。field, method 可以被其他类访问，前提是有访问 class 的权限。

private： field, method 无法被其他类访问。嵌套类可以访问 private field, method.

protected 作用与继承关系。定义为 protected 的字段和方法可以被子类访问，包括子类的子类。

包作用域是指一个类允许访问同一个包的没有 public, private 修饰的 class, 以及没有 public, protected, private 修饰的字段和方法。

局部变量：方法内部定义的变量称为局部变量。

final: 
修饰类，阻止被继承。
修饰方法，阻止被子类覆写
修饰字段，阻止被修改
修饰局部变量阻止被修改。

一个 .java 文件只能包含一个 public 类，但可以包含多个非 public 类。如果有 public 类，文件名必须和 public 类的名字相同。

classpath 类路径，指定搜索类的路径的环境变量
不推荐在系统环境变量中设置 classpath，这样会污染整个环境。推荐 JVM 启动时传入 -classpath, -cp 参数。 
没有设置环境变量或者没有传入参数， java 默认的 classpath 为当前目录。
如执行 java name.misc.Hello， 会搜索 ./name/misc/Hello.class 字节码。
java 核心库不需要设置 classpath.

java -cp ./hello.jar abc.xyz.Hello
会在 hello.jar 中搜寻 Hello 类。
jar 就是一个 zip 包，可以使用 zip 打包然后修改扩展名
MANIFEST.MF 指定 Main-Class 和其他信息，大型项目可以使用 Maven 构建工具。







