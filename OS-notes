### 连续内存分配：

空闲内存不能利用：
1. 外碎片，分配单元间的未使用内存
2. 内碎片，分配单元中的未使用内存

分区的动态分配：
1. 一个程序准许运行在内存中时，分配一个连续的区间
2. 分配一个连续的内存区间给运行的程序以访问数据
分配策略：
1. 首次适配
分配给应用程序第一个可以满足需求的内存区间。按地址从低到高
2. 最优适配
大小最匹配。
3. 最差适配
使用最大空闲内存区间。

1. 压缩式碎片整理。
2. 交换式碎片整理。


### 非连续内存分配：
1. 分段 segmentation
2. 分页 paging
分段。堆，栈等
段访问机制：
1. 段寄存器 + 地址寄存器
2. 单地址方案，单地址包含段地址和段内偏移组成
段表，base + limit

分页。页号 + 页内偏移
划分物理内存至固定大小的帧 frame
划分逻辑地址至相同大小的页 page
pages to frames
帧： 帧号 + 帧内偏移 -> 物理地址
页： 页号 + 页内偏移 -> 逻辑地址
page -> (page table) frame

页是连续的空间，帧不是连续的空间。
页表项的内容： flag, 帧号

分页机制的性能问题：
1. 页表可能空间大
2. 访问一个内存单元需要2次内存访问
处理方案：
caching, indirection
1. TLB，缓存近期访问的页帧转换表项
2. 二级页表。一级页表存二级页表的基址

反向页表：
页寄存器， 关联内存，哈希函数

### 虚拟内存
1. 程序大， 手动覆盖，把需要的指令和数据保存在内存中，单个程序内部
2. 多个程序，自动交换，暂时不执行的程序送到外存中，多个程序间
3. 自动的虚拟存储技术
编写局部性好的代码

虚存技术基本特征：
1. 大的用户空间
2. 部分交换
3. 虚拟地址空间使用的不连续。由于部分交换导出内存，访问的页不在内存。（由操作系统导入内存）

请求调页。页面置换
页面置换算法： 缺页中断发生，内存已满，选择内存中哪个物理页面被置换
1. 最优页面置换算法
对保存在内存中的每一个逻辑页面，计算在下一次访问之前还需等待多长时间，选择等待时间最长的那个作为被置换的页面
2. 先进先出算法： 选择在内存中驻留时间最长的页面淘汰之
3. 最近最久未使用算法： least recently used, LRU
4. 时钟页面置换算法： 
5. 二次机会法： 利用 dirty bit, access bit 减少访问磁盘的次数，增强的时钟页面置换算法
6. 最不常用算法： LFU 选择访问次数最少的页面淘汰之

belady 现象： 采用 FIFO 算法时，出现分配的物理页面数增加，缺页率反而提高的异常现象

LRU 算法性能较好，开销大。FIFO 算法开销小，有 belady 现象。折衷 clock 算法
 
### 全局页面置换算法
程序的局部性原理，工作集模型用来分析程序的局部性。
常驻集： 当前时刻，进程实际驻留在内存中的页面集合
1. 工作集页置换算法。工作集窗口固定
2. 缺页率页面置换算法。
抖动问题

### 进程： 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程
1. 进程的组成：
程序的代码
程序处理的数据
程序计数器的值
一组通用的寄存器，堆栈
一组系统资源

程序是产生进程的基础
程序的每次运行构成不同的进程
进程是程序功能的体现
通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包括多个程序

进程是动态的，程序是静态的： 程序是有序代码的集合，进程是程序的执行，进程有核心态/用户态
进程是暂时的，程序是永久的： 进程是一个状态变化的过程，程序可永久保存

进程的特点：
动态性。并发性，一个处理器不能并行，多个处理器才可以并行。独立性。制约性（因访问共享数据/资源或进程间同步而产生制约）
描述进程的数据结构： 进程控制块 process control block, PCB，作为进程存在的唯一标志
PCB 包含三大类信息：
1. 进程标识信息 2. 处理及状态信息保存区（用户可见寄存器，控制和状态寄存器，栈指针）
3. 进程控制信息（调度和状态信息，进程间通信信息，存储管理信息，进程所用资源，有关数据结构连接信息）
PCB 组织方式： 链表， 索引表（数组）

进程状态：
1. 进程的生命期管理
进程创建。系统初始化时；用户请求创建一个新进程；正在运行进程执行了创建进程的系统调用；
进程运行。内核选择一个就绪的进程，占用处理机并执行
进程等待。进程等待（阻塞se）条件： 请求并等待系统服务，无法马上完成；启动某种操作，无法马上完成；需要的数据没有到达;
进程唤醒（被其他进程或操作系统唤醒）。被阻塞进程需要的资源可被满足；被阻塞进程等待的事件到达；将该进程的 PCB 插入就绪队列
进程结束。正常退出；错误推出；致命错误；被其他进程所杀

进程状态变化模型：
运行状态；就绪状态；等待（阻塞）状态；创建状态；结束状态

进程挂起：
进程在挂起状态，意味着进程没有占用内存空间，处于挂起状态的进程映像在磁盘上
1. 阻塞挂起状态 blocked-suspend
2. 就绪挂起状态 ready-suspend
内存到外存：
阻塞到阻塞挂起
就绪到就绪挂起
运行到就绪挂起

外存时的状态变化：
阻塞挂起到就绪挂起

外存到内存： 解挂/激活
就绪挂起到就绪
阻塞挂起到阻塞

### 线程管理：
进程理解：
1. 资源组合的角度
2. 运行的角度: 由线程组成（共享进程提供的资源）
进程是资源分配单位，线程是 CPU 调度单位
线程能减少并发执行的时间和空间开销：
创建，终止时间短，线程切换时间短，共享内存和文件系统资源等，可进行不通过内核的通信

线程的实现：
1. 用户线程： POSIX Pthreads, Mach C-threads, Solaris threads
2. 内核线程： Windows, Solaris, Linux
3. 轻量级线程： Solaris (LoghtWeight Process)

用户线程的缺点：
一个线程发起系统调用而导致进程阻塞，进程的所有线程都不能执行
一个线程运行之后，除非主动交出 CPU 的使用权，否则进程中其他线程都得不到执行
时间片分给进程，多线程执行时，每个线程得到的时间片较少

上下文切换：

exec() 调用允许一个进程加载一个不同的程序并且在 main 开始执行
fork() 的简单实现：
对子进程分配内存。复制父进程的内存和 CPU 寄存器到子进程里。
99%的情况下，在调用 fork() 之后调用 exec()，因此内存复制没有用处
vfork() - 不复制内存
Copy on Write (COW) 技术，复制页表，不复制内存，只有写内存时触发内存复制

wait() 被父进程用来等待子进程的结束
1. 子进程向父进程返回一个值，父进程必须接受这个值并处理

CPU 调度：
选择进程/线程作为将要运行的下一个进程/线程

调度算法：
1. FCFS 先来先服务。
2. SPN, SJF, SRT 短进程优先，短作业优先，短剩余时间优先。可以是可抢占的或者不可抢占的。连续的短任务会使长任务饥饿。无法预知进程执行时间
3. HRRN 最高响应比优先
4. 轮循
5. 多级反馈队列
6. 公平共享调度

实时操作系统调度算法：
1. RM 速率单调调度
2. EDF 最早期限调度

多处理器调度：
选择哪个 CPU;探测别的 CPU 繁忙程度

优先级反转： 优先级继承；优先级天花板

原子操作： 一次不存在任何中断或者失败的执行

临界区： 访问共享资源的代码就是临界区
特点：
互斥， progress，有忙等待，无忙等待（可选）
实现：
1. 禁用硬件中断
没有中断，没有上下文切换，因此没有并发
2. 基于软件的解决方案
3. 原子操作指令

信号量

管程: 

IPC:
信号。signal 软件中断通知事件处理。SIGKILL
管道。需要父进程，子进程关系。字节流。间接通信
消息队列。无需父子关系。结构化数据。间接通信
共享内存。直接通信。需要同步数据访问
套接字。
