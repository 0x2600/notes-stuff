1.11 内联函数
定义时声明 inline

1.14 函数的默认参数
默认参数放在形参列表的最后面，值可以指定字面常量或者使用变量表达式
float d = 1.0
void foo(float a=d+1.0){
    // function body here.
}
简单点，函数定义时指定默认参数

1.16 函数重载 function overloading
函数名字相同，参数列表不同(参数个数，类型，顺序不同)。返回值不能作为重载的依据。
#include <iostream>
using namespace std;

void Swap(int a, int b){
	cout << b << " " << a << endl;
}

void Swap(float a, float b){
	cout << b << " " << a << endl;
}

int main(){
	int x, y;
	cin >> x >> y;
	Swap(x, y);
	
	float x1, y1;
	cin >> x1 >> y1;
	Swap(x1, y1);

}

2.1 类的定义和对象的创建
类通常定义在函数外面
class Stu{
public:    
    int x;
    void foo(){
        cout << x;
    }
};
int main(){
    // 在栈上创建对象
    Stu ming;
    ming.x = 20;
    ming.foo();

    // 使用对象指针
    Stu *pming = &ming;
    pming->foo(); 

    // 堆上创建对象. new 在堆上创建出来的对象是匿名的，需要指针指向它。
    // 栈内存是程序自动管理的，不能使用 delete 删除。堆内存有程序员管理， new 和 delete
    // 成对出现。
    Stu *phan = new Stu;
    phan->x = 30;
    phan->foo();
}

2.2 类的成员变量和成员函数
在类体中定义的成员函数会自动成为内联函数。内联函数一般不是我们期望的(除非成员函数比较
短小)。所以建议在类体内部对成员函数作声明，在外部定义。
如果希望函数定义在类外部，又希望是内联函数。定义时加 inline 关键字。

// 外部
void Stu::foo(){
    cout << x << endl;
}

2.3 类成员的访问权限和封装
类内部。无访问权限的限制
类外部。对象访问成员，可以访问 public 属性成员。
类的声明和成员函数的定义都是类定义的一部分。通常将类声明放在头文件中，将成员函数
的定义放在源文件中。

2.6 构造函数
名字和类名相同，没有返回值，没有变量来接收返回值。public 属性。
class Stu{
private:
    char *mname;
    int mage;
public:
    Stu(char *, int);
    void greet(){
        cout << mname << endl;
    }
};

Stu::Stu(char *name, int age){
    mname = name;
    mage = age;
}

int main(){
    Stu han("Han", 20);
    han.greet();
    return 0;
}

构造函数重载

调用没有参数的构造函数，可以省略括号 Stu han(); Stu han; Stu *phan = new Stu(); Stu *phan = new Stu;

2.7 构造函数初始化列表
class Stu{
public:
    Stu(char *name, int age);
};

Stu::Stu(char *name, int age):m_name(name), m_age(age){
    // TODO;
}

成员变量的初始化顺序与初始化列表无关，只与成员变量在类中声明的顺序有关
class Demo{
private:
    m_a;
    m_b;
public:
    Demo(int b);
}

Demo::Demo(int b):m_b(b), m_a(m_b){}
等价于
Demo::Demo(int b){
    m_a = m_b;
    m_b = b;
}
在栈上创建对象时，m_a 初始化的值不确定。

初始化 const 成员变量，唯一方法

2.8 析构函数
名字，类名前加 ~,没有参数，不能被重载(只有一个析构函数)

内存分区: 所有函数之外创建的对象是全局对象，位于全局数据区，程序结束执行时调用这些
对象的析构函数。
函数内部创建的对象是局部对象，栈区，函数执行结束调用这些对象的析构函数。
new 创建的对象位于堆区，delete 删除时调用析构函数。

2.11 this 指针
const 指针，指向当前对象，只能在类的内部使用。，可以访问 private, protected, public 成员。只有当对象被创建后 this 才有意义，因此不能在 static 函数中使用。

2.12 static 静态成员变量
public:
    static int m_total;
static 成员变量属于类，在类声明的外部进行初始化，初始化时不能加 static。在内存分区的全局数据区分配内存，程序结束释放，即不随对象的创建而分配内存，也不随对象的销毁而释放内存。必须初始化，在类体外进行，不赋值默认初始化为0。可以通过对象名访问，也可以通过类名访问，遵循权限限制。

2.13 static 静态成员函数
静态成员函数与普通成员函数，普通成员函数有 this 指针，可以访问类中的任意成员;静态成员函数只能访问静态成员。
声明时加 static, 定义时不能加 static，可以通过类调用，也可以通过对象调用。
public:
    static int getTotal();

2.14 const 成员变量和成员函数
const 成员变量声明时加 const，只能通过构造函数的初始化列表初始化。
const 成员函数，可以使用类中的所有成员变量，但是不能修改他们的值。声明和定义时在函数头部的结尾加 const
char *getname() const;
char *Stu::getname() const{
    ;
}

2.15 const 对象
const 对象只能调用类的 const 成员。
const Stu stu();
Stu const stu()

const Stu *pstu = new Stu()
Stu const *pstu = new Stu()

2.16 友元函数和友元类 friend 关键字
友元函数 
1) 非成员函数声明为友元函数

class Stu{
pulic:
    firend void show(Stu *pstu);
};

void show(Stu *pstu){
    cout << pstu->some_private_var;
}
int main(){
    ;
}

2) 其他类的成员函数声明为友元函数
class Addr;
class Stu{
public:
    char *getCity(Addr *paddr);

};
class Addr{
    friend char *Stu::getCity(Addr *paddr);
};
友元类 略

2.19 string
#include <string>
string 类的转换函数 c_str() 将 string 转换为 C 风格的字符串，返回指针。
+， += 字符串拼接。操作数可以是string, string; string, c_str; string, 字符数组; string, 字符
string 增删改查:
insert(pos, str)
erase(pos, len=npos)
substr(pos=0,len=npos)
size_t find(string &, pos=0)
size_t find(char *, pos=0)
rfind()

3.1 引用
type &name = data;
int b;
int &a = b;
```
int main(){
    int a = 99;
    int &r = a;
    r = 90; // a = 90
}
```
void swap3(int &a, int &b){
    int tmp = a;
    a = b;
    b = tmp;
}
// call swap3
int num1, num2;
swap3(num1, num2);

4. 继承与派生









